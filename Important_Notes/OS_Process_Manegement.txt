

						+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						-			                	+
						+     Operating System		    -
						-           |			        +
						+           |			        -
						-     Process Manegment		    +
						+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+



    	Index
    
    1-> Process states
            |
            |----->>>> NEW, READY, RUNNING, WATING, SUSPENDED,TERMINATED
            |
            |----->>>> ORPHAN,
            |          ZOMBIE,
            |          DEAMON.
            |----->>>> Memory Layout of a process[ Stack, Heap, Data, Text(Code) ]

    2-> Process control Block
    3-> Process Operations
    4-> Process sheduling
            |
            |------------->>>> Pre-emptive, Non Pre-emptive
            |
            |------------->>>> Process Schudler
            |                   1. Long term Schudler
            |                   2. short term Schudler
            |                   3. Medium term schudler
            |
            |------------->>>> Context Switching
            |
            |
            |------------->>>> Scheduling Criteria
            |                   1. CPU Utilization
            |                   2. Throughput
            |                   3. Turnaround Time
            |                   4. Waiting Time
            |                   5. Load Average
            |                   6. Response Time
            |
            |-------------->>>> Scheduling Algorithms
                                1. First Come First Serve (FCFS)
                                2. Shortest Job First (SJF)
                                3. Shortest Remaining Time First (SRTF)
                                4. Longest Job First (LJF)
                                5. Longest Remaining Time First (LRTF)
                                6. Priority Scheduling
                                7. Round Robin Scheduling (RR)


    5-> Process Synchronization
    6-> Interprocess communication
    7-> Deadlock


1)
----------------------------------------------------------
Differences between the Kernel and the Operating System  |
----------------------------------------------------------

1-> 	The Operating System is a system software containing various Programs in it while the Kernel is the central Program of the Operating System.

2-> 	The Kernel performs the lowest level functions of the Operating System like

	Process management,
	File management,
	Memory management,
	Device management, 
	Input/output communication, etc...,

	while the Operating System performs surplus functions like providing security to the data and files in the system,
	providing access controls to the User and hence maintaining privacy.

3->[IMP]

	The Kernel acts as an interface between the user level programs and the hardware whereas the Operating System acts as an interface

	between the user and the hardware. Here, it is important to note that the Operating system can directly interact with the user 

	as it is system software, but the Kernel cannot do so, because it is just a Program. So, for any sort of information exchange with the user,

	whether it be the input from the user or output to the user, the kernel performs it through the applications, 

	and these applications are again, a part of the Operating System.

	4-> Operating System is a System Software which is the first one to get loaded into the main memory as soon as the system is turned on.

	The Kernel is that Program of the Operating System which gets loaded into the memory before any other Program in the Operating System.

==================================================================================================================================================
2)

	The process is the running instance of a program which occupies space in memory (RAM),
	-------------------------------------------------------------------------------------
	a program is a passive entity and process is an active entity.
	-------------------------------------------------------------
	a process may passes through the states as given below.
	------------------------------------------------------

	1-> New
	2-> Ready
	3-> Running
	4-> Waiting
	5-> Suspended
	6-> Terminated



		|-------------|                                                          +-------------+
		| NEW PROCESS |--------+                                                 |             |
		|-------------|        |                                          +---->>| Terminated  |
        				       |                                          |      |             |
		        		       |                                          |      +-------------+
				               |                                          |  
				               |                                          | 
                         +-------------+		Dispacter            +----------+
                         |     	       | --------------------->>>>   |	    	|
                         |    READY    | 		            	     |	Running |
                         |             | <<<<---------------------   |          |
                         +-------------+		Interrupt	         +----------+
                               |          \                                    |
	            			   |           \                                   |  Going For I/O 
        Process Going to       |            \                                  | 
        Swapping Area	       |             \                                 | 
                               |              \   I/O Completed                |  
                    +------------+             +<<<<<---------------      +---------+
                    |            |                                 |      |         |
                    | Suspended  |                                 |<<<---|	Wating  |
                    |	         |                                        |         |
                    +------------+                                        +---------+

								        Wating in I/O Queue





1) New State
   ----------
	When a program is double-clicked like a program.exe file in windows, the process comes in new state and 
	a process ID is provided to it and it starts loading in memory.
	The process of selecting a process for loading in memory is done by Long Term Scheduler.

2) Ready State
  ------------
        When a program is double-clicked like a program.exe file in windows, the process comes in new state and
        a process ID is provided to it and it starts loading in memory.
        The process of selecting a process for loading in memory is done by Long Term Scheduler.

    3) Running State
      ---------------
        The Short-term scheduler selects a process from ready queue to run (i.e provide CPU), then process state
        become running. At this moment instruction of the program is executing. 

    4) Waiting State
      ---------------
        The process often requires input/output from various devices for that purpose process move to a new state
        called waiting for a state where the process performs input and output from devices like monitor, keyboard etc.
        If a process is already performing I/O then other process wait for their turn in device waiting queue.

    5) Suspended State
    -----------------
        As the memory is limited it cannot contain multi-process at any instance, suppose a new process want to come
        in memory but there is required space available, and this process has high priority so mid-term scheduler will
        select a process of low priority and place it in swap area of hard disk, so that when space is available it can
        again be called out . This state of a process is suspended.

    6) Terminated State
      ------------------
        When a process performs all the task then PCB of the process is deleted and a process is removed from the memory.

    --------------------------------------------------------------------------------------------------------------------------------

        A process held a number of attributes like hardware, memory, CPU, and progress.

        Process classification

        A process can be broadly categorized into the following two types based on its execution:

    1-> I/O-Bound process
       --------------------
        An I/O-bound process is a process whose execution time is determined mainly by the amount of time it spends completing I/O operations.

    2-> CPU-Bound process
       --------------------
        A CPU-bound process is a process whose execution time is determined by the speed of the CPU it runs on.
        A CPU-bound process can complete its execution faster if it is running on a faster processor.

        Note: 
        There is a third category - Memory-bound process.
        -------------------------------------------------
        However, since RAM serves as I/O for the processor, this can be considered as an instance of the I/O-bound process type.

        Further a process can be broadly categorized into the following two types based on execution mode.

        -------------+
    1-> Kernel mode: |
        -------------+

        In the kernel mode, a process has unrestricted access to the system hardware it can execute privileges instruction and
        can access both user and kernel address space.

        Example: Most of the device drivers in the system execute as kernel mode processes.

        -----------+
    2-> User mode: |
        -----------+
        
        In the user mode it has no direct access to the underlying system hardware it can only access its own user address space of other processes and it cannot execute privileged instructions.

        Example: web- browser is executed as a user- mode process.


    ==================================================================================================================================================

    2->>>>>
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    Zombie and orphan processes   |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        Suppose there are two processes. One is parent process while the other is child process. In a real time, there can be two scenarios: 

        The parent dies or gets killed before the child. 
        In the above scenario, the child process becomes the orphan process (as it has lost its parent).
        In Linux, the init process comes to the rescue of the orphan processes and adopts them.
        This means after a chile has lost its parent, the init process becomes its new parent process. 

    The child dies and parent does not perform wait() immediately. 
    ---------------------------------------------------------------
        Whenever the child is terminated, the termination status of the child is available to the parent through the wait() family of calls.

        So, the kernel does waits for parent to retrieve the termination status of the child before its completely wipes out the child process.

        Now, In a case where parent is not able to immediately perform the wait() (in order to fetch the termination status), 

        the terminated child process becomes zombie process. A zombie process is one that is waiting for its parent to fetch its termination status.
                                                            ----------------------------------------------------------------------------------------  
        Although the kernel releases all the resources that the zombie process was holding before it got killed,
        ---------------------------------------------------------------------------------------------------------
        some information like its termination status, its process ID etc are still stored by the kernel.
        -------------------------------------------------------------------------------------------------
        Once the parent performs the wait() operation, kernel clears off this information too. 
        -----------------------------------------------------------------------------------------

    +-+-+-+-+-+-+-+-+
    Daemon process  |
    +-+-+-+-+-+-+-+-+

    A process that needs to run for a long period of time and does not require a controlling terminal,
    these type of processes are programmed in a way that they becomes a daemon processes.
    For example, monitoring software like key-logger etc are usually programmed as daemon processes. A daemon process has no controlling terminal. 

    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    Memory layout of a process  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        A process can broadly be defined into following segments : 

        Stack 

            Stack contains all the data that is local to a function like variables, pointers etc. Each function has its own stack.
            Stack memory is dynamic in the sense that it grows with each function being called. 

        Heap

            Heap segment contains memory that is dynamically requested by the programs for their variables.

        Data 
            All the global and static members become part of this segment.

        Text 
            All the program instructions, hard-coded strings, constant values are a part of this memory area. 

    ==================================================================================================================================================
    ==================================================================================================================================================

    Q: What is Process Scheduling?
       ---------------------------

        The act of determining which process is in the ready state, and should be moved to the running state is known as Process Scheduling.
        -----------------------------------------------------------------------------------------------------------------------------------
        The prime aim of the process scheduling system is to keep the CPU busy all the time and to deliver minimum response time for all programs.
        -----------------------------------------------------------------------------------------------------------------------------------------
        For achieving this, the scheduler must apply appropriate rules for swapping processes IN and OUT of CPU.

        Scheduling fell into one of the two general categories:
                        ------------------------------------

        1>> Non Pre-emptive Scheduling: When the currently executing process gives up the CPU voluntarily.
        ---------------------------
        2>> Pre-emptive Scheduling: When the operating system decides to favour another process, pre-empting the currently executing process.
        --------------------------

    Q: What are Scheduling Queues?
       -------------------------------

            >>> All processes, upon entering into the system, are stored in the Job Queue.
                                                                                ----------
            >>> Processes in the Ready state are placed in the Ready Queue.
                                                              -------------  
            >>> Processes waiting for a device to become available are placed in Device Queues. There are unique device queues available for each I/O device.
                                                                                 --------------


        A new process is initially put in the Ready queue. It waits in the ready queue until it is selected for execution(or dispatched).

        Once the process is assigned to the CPU and is executing, one of the following several events can occur:

            >>> The process could issue an I/O request, and then be placed in the I/O queue.

            >>> The process could create a new subprocess and wait for its termination.

            >>> The process could be removed forcibly from the CPU, as a result of an interrupt, and be put back in the ready queue.



         +-+-+--+-+-+-+-+                     +-+-+-+ --------------->>>> Terminated
         | Ready Queue  |---------------->>>> | CPU |
         +-+-+--+-+-+-+-+                     +-+-+-+ ----------------+
          ^                                                           |
          ^                                                           |
          |                                                           |
          |  +-+-+      +-+-+-+-+-++      +-+-+-+-+-+-+-+             |
          +--|I/O|<<<---|I/O Queue |<<----|  I/O Request | <<<--------+          
          |  +-+-+      +-+-+-+-+-++      +-+-+-+-+-+-+-+             |
          |                                                           |         
          |                 +-+-+-+-+-+-+-+-+-+-+                     | 
          +<<<<------------ | Time slice Expire |<<<<<----------------|
          |                 +-+-+-+-+-+-+-+-+-+-+                     |
          |                                                           |
          |          +-+-+-+-+-+-+-+-+-        +-+-+-+-+-+-+-         |
          +<<<<------| Child Executed |--------| Fork Child |<<<------|
          |          +-+-+-+-+-+-+-+-+-        +-+-+-+-+-+-+-         |
          |                                                           |
          |                                                           |
          |        +-+-+-+-+-+-+-+-+-+      +-+-+-+-+-+-+-+-+-+-++    |
          +<<<<----| Interrupt Occur |------| Wait For Interrupt |<<--|
                   +-+-+-+-+-+-+-+-+-+      +-+-+-+-+-+-+-+-+-+-++
                    
          
        In the first two cases, the process eventually switches from the waiting state to the ready state, and is then put back in the ready queue.
        A process continues this cycle until it terminates, at which time it is removed from all queues and has its PCB and resources deallocated.
                                                        --------------------------------------------------------------------------------------  

    Types of Schedulers :->>>
    --------------------
    There are three types of schedulers available:

        1-> Long Term Scheduler
        2-> Short Term Scheduler
        3-> Medium Term Scheduler


     1) Long Term Scheduler
        -------------------

        Long term scheduler runs less frequently. Long Term Schedulers decide which program must get into the job queue.
        From the job queue, the Job Processor, selects processes and loads them into the memory for execution.
        Primary aim of the Job Scheduler is to maintain a good degree of Multiprogramming.
        ----------------------------------------------------------------------------------
        An optimal degree of Multiprogramming means the average rate of process creation is equal to the average departure rate of processes
        from the execution memory.

     2) Short Term Scheduler
        ---------------------

        This is also known as CPU Scheduler and runs very frequently. The primary aim of this scheduler is to enhance CPU performance and
                              ---------------------------------------  ------------------------------------------------------------------
        increase process execution rate.
        -------------------------------

     3) Medium Term Scheduler
        ---------------------

        This scheduler removes the processes from memory (and from active contention for the CPU), and thus reduces the degree of multiprogramming.
        At some later time, the process can be reintroduced into memory and its execution can be continued where it left off.
        This scheme is called swapping. The process is swapped out, and is later swapped in, by the medium term scheduler.
                              --------- ---------------------------------------------------------------------------------- 
        Swapping may be necessary to improve the process mix, or because a change in memory requirements has overcommitted available memory,
        requiring memory to be freed up. This complete process is descripted in the below diagram:


    What is Context Switch?
    ------------------------

        Switching the CPU to another process requires saving the state of the old process and
        loading the saved state for the new process. This task is known as a Context Switch.
                                                                  ---------------------------      
        The context of a process is represented in the Process Control Block(PCB) of a process;
        it includes the value of the CPU registers, the process state and memory-management 
        information. When a context switch occurs, the Kernel saves the context of the old process
        in its PCB and loads the saved context of the new process scheduled to run.

        Context switch time is pure overhead, because the system does no useful work while switching.
        Its speed varies from machine to machine, depending on the memory speed, the number of registers
        that must be copied, and the existence of special instructions(such as a single instruction to
        load or store all registers). Typical speeds range from 1 to 1000 microseconds.
        
        Context Switching has become such a performance bottleneck that programmers are using new
        structures(threads) to avoid it whenever and wherever possible.

    CPU Scheduling: Scheduling Criteria :-
    ------------------------------------

        There are many different criterias to check when considering the "best" scheduling algorithm, they are:

     1) CPU Utilization :-
        ---------------

        To make out the best use of CPU and not to waste any CPU cycle, CPU would be working most of the time(Ideally 100% of the time).
        Considering a real system, CPU usage should range from 40% (lightly loaded) to 90% (heavily loaded.)
        
     2) Throughput :-
        -------------

        It is the total number of processes completed per unit time or rather say total amount of work done in a unit of time.
        This may range from 10/second to 1/hour depending on the specific processes.
        
     3) Turnaround Time :-
        -----------------

        It is the amount of time taken to execute a particular process, i.e. The interval from time of submission of the process
        to the time of completion of the process(Wall clock time).
        
     4) Waiting Time :-
        ----------------

        The sum of the periods spent waiting in the ready queue amount of time a process has been waiting in the ready queue to
        acquire get control on the CPU.
        
     5) Load Average :-
        -------------

        It is the average number of processes residing in the ready queue waiting for their turn to get into the CPU.
        
     6) Response Time :-
        ---------------

        Amount of time it takes from when a request was submitted until the first response is produced.
        Remember,it is the time till the first response and not the completion of process execution(final response).
        
    +++ In general CPU utilization and Throughput are maximized and other factors are reduced for proper optimization.
        --------------------------------------------------------------------------------------------------------------                            
    >>> Operating system performs the task of scheduling processes based on priorities using these following algorithms:
        
       1) First come first serve (FCFS) :-
          ------------------------------  
           In this scheduling algorithm the first process entered in queue is processed first.
       
       2) Shortest job first (SJF) :-
          -------------------------  
           In this scheduling algorithm the process which requires shortest CPU time to execute is processed first.
       
       3) Shortest Remaining Time First (SRTF) scheduling :-
          ------------------------------------------------  
        This scheduling Algorithm is the preemptive version of the SJF scheduling algorithm.
        In this, the process which is left with the least processing time is executed first.
        
       4) Longest Job First (LJF) :-
          ------------------------  
        In this type of scheduling algorithm, the process with the maximum time required to execute is scheduled first.
        In this type of scheduling is not widely used because it is not a very effective way of scheduling,
        as the average turn-around time and the average waiting time are maximum in this case.
        
       5) Longest Remaining Time First (LRTF) :-
          ------------------------------------  
        As SRTF is to SJF, LRTF is the preemptive version of the LJF scheduling algorithm.
       
       6) Priority scheduling :-
          ---------------------  
        In this scheduling algorithm the priority is assigned to all the processes and the process with highest priority
        executed first. Priority assignment of processes is done on the basis of internal factor such as CPU and memory 
        requirements or external factor such as user’s choice. The priority scheduling algorithm supports preemptive and
        non - preemptive scheduling policy.
        
       7) Round Robin (RR) scheduling :-
          ------------------------------  
       In this algorithm the process is allocated the CPU for the specific time period called time slice, which is normally
       of 10 to 100 milliseconds. If the process completes its execution within this time slice, then it is removed from the
       queue otherwise it has to wait for another time slice.


    ==================================================================================================================================================
Process Synchronization
Process Synchronization means sharing system resources by processes in a such a way that, Concurrent access to shared data is handled thereby minimizing the chance of inconsistent data. Maintaining data consistency demands mechanisms to ensure synchronized execution of cooperating processes.
Process Synchronization was introduced to handle problems that arose while multiple process executions. Some of the problems are discussed below.


Critical Section Problem
A Critical Section is a code segment that accesses shared variables and has to be executed as an atomic action. It means that in a group of cooperating processes, at a given point of time, only one process must be executing its critical section. If any other process also wants to execute its critical section, it must wait until the first one finishes.








    ==================================================================================================================================================


    ==================================================================================================================================================


    ==================================================================================================================================================


    ==================================================================================================================================================


    ==================================================================================================================================================



















